/**
 * @file type_trait
 * @author theflysong (song_of_the_fly@163.com)
 * @brief type_trait
 * @version alpha-1.0.0
 * @date 2026-01-19
 *
 * @copyright Copyright (c) 2026
 *
 */

#pragma once

#include <cstddef>

namespace std {
    // 基础模板：integral_constant（整型常量包装器）
    template <typename T, T v>
    struct integral_constant {
        using value_type = T;
        using type       = integral_constant<T, v>;  // 自身类型

        static constexpr value_type value = v;

        // 转换函数：可以转换为值类型
        constexpr operator value_type() const noexcept {
            return value;
        }

        // 函数调用运算符：可以像函数一样使用
        constexpr value_type operator()() const noexcept {
            return value;
        }
    };

    // 布尔类型特化
    template <bool __v>
    using bool_constant = integral_constant<bool, __v>;
    using true_type     = bool_constant<true>;
    using false_type    = bool_constant<false>;

    // declval
    template <typename T>
    T&& declval() noexcept;

    // Type Relations

    // is_same
    template <typename _Tp, typename _Up>
    struct is_same : public bool_constant<__is_same(_Tp, _Up)> {};
    template <typename _Tp, typename _Up>
    inline constexpr bool is_same_v = is_same<_Tp, _Up>::value;

    // is_base_of
    template <typename _Base, typename _Derived>
    struct is_base_of : public bool_constant<__is_base_of(_Base, _Derived)> {};
    template <typename _Base, typename _Derived>
    inline constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;

    // is_convertible
    template <typename _Fp, typename _Tp>
    struct is_convertible : bool_constant<__is_convertible(_Fp, _Tp)> {};
    template <typename _Fp, typename _Tp>
    inline constexpr bool is_convertible_v = is_convertible<_Fp, _Tp>::value;

    // Const - Volatile Modifiers
    template <typename _Tp>
    struct remove_const {
        using type = _Tp;
    };
    template <typename _Tp>
    struct remove_const<const _Tp> {
        using type = _Tp;
    };
    template <typename _Tp>
    struct remove_volatile {
        using type = _Tp;
    };
    template <typename _Tp>
    struct remove_volatile<volatile _Tp> {
        using type = _Tp;
    };
    // remove_cv
    template <typename _Tp>
    struct remove_cv {
        using type = __remove_cv(_Tp);
    };

    // add_const
    template <typename _Tp>
    struct add_const {
        using type = const _Tp;
    };
    // add_volatile
    template <typename _Tp>
    struct add_volatile {
        using type = volatile _Tp;
    };
    // add_cv
    template <typename _Tp>
    struct add_cv {
        using type = volatile const _Tp;
    };

    // 别名
    template <typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;
    template <typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;
    template <typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;
    template <typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;
    template <typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;
    template <typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;

    // Type Traits

    // is_enum
    template <typename _Tp>
    struct is_enum : public bool_constant<__is_enum(_Tp)> {};

    // is_scoped_enum
    template <typename _Tp>
    struct is_scoped_enum : public bool_constant<__is_scoped_enum(_Tp)> {};

    // is_union
    template <typename _Tp>
    struct is_union : public bool_constant<__is_union(_Tp)> {};

    // is_class
    template <typename _Tp>
    struct is_class : public bool_constant<__is_class(_Tp)> {};

    // is_array
    template <typename _Tp>
    struct is_array : public bool_constant<__is_array(_Tp)> {};

    // is_pointer
    template <typename _Tp>
    struct is_pointer : public bool_constant<__is_pointer(_Tp)> {};

    // is_function
    template <typename _Tp>
    struct is_function : public bool_constant<__is_function(_Tp)> {};

    // is_void
    template <typename _Tp>
    struct is_void : public false_type {};
    template <>
    struct is_void<void> : public true_type {};
    template <>
    struct is_void<const void> : public true_type {};
    template <>
    struct is_void<volatile void> : public true_type {};
    template <>
    struct is_void<const volatile void> : public true_type {};

    // 别名
    template <typename _Tp>
    inline constexpr bool is_enum_v = is_enum<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_scoped_enum_v = is_scoped_enum<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_union_v = is_union<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_class_v = is_class<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_array_v = is_array<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_function_v = is_function<_Tp>::value;
    template <typename _Tp>
    inline constexpr bool is_void_v = is_void<_Tp>::value;

    // extent

    // 默认情况: 非数组类型，大小为0
    template <typename, unsigned _Uint = 0>
    struct extent : public integral_constant<size_t, 0> {};

    // 如果是数组类型, 且已递归到最外层, 则返回数组大小
    template <typename _Tp, unsigned _Size>
    struct extent<_Tp[_Size], 0> : public integral_constant<size_t, _Size> {};

    // 如果还未递归到最外层, 继续递归
    template <typename _Tp, unsigned _Uint, unsigned _Size>
    struct extent<_Tp[_Size], _Uint> : public extent<_Tp, _Uint - 1>::type {};

    // 特化: 不定长数组
    template <typename _Tp>
    struct extent<_Tp[], 0> : public integral_constant<size_t, 0> {};
    template <typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint> : public extent<_Tp, _Uint - 1>::type {};

    // 别名
    template <typename _Tp, unsigned _Uint = 0>
    inline constexpr size_t extent_v = extent<_Tp, _Uint>::value;

    // rank
    template <typename _Tp>
    struct rank : public integral_constant<size_t, __array_rank(_Tp)> {};

    // 别名
    template <typename _Tp>
    inline constexpr size_t rank_v = rank<_Tp>::value;
}  // namespace std